# 2. 프로토콜 HTTP

HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이며 클라이언트-서버 프로토콜이다.

## 클라이언트-서버 프로토콜
(일반적으로 웹 브라우저인) 수신자 측에 의해 요청이 초기화되는 프로토콜이다.    

리소스를 요구하는 쪽이 클라이언트, 제공하는 쪽이 서버.

HTTP는 클라이언트와 서버 간의 역할을 명확하게 구별하고 있다.

## 리퀘스트와 리스폰스

클라이언트와 서버는 개별적인 메시지 교환으로 통신하게 되는데, 클라이언트로부터 전송되는 메시지를 '리퀘스트' 라고 하며, 서버에서 응답으로 전송되는 메시지를 '리스폰스' 라고 한다.    

→ 반드시 클라이언트로부터 통신이 시작한다!! 서버 측이 리퀘스트를 수신하지 않고 리스폰스 하는 경우는 없다.


리퀘스트 메시지는 메소드, URI, 프로토콜 버전, 옵션 리퀘스트 헤더 필드, 엔티티로 구성된다.


리스폰스 메시지는 프로토콜 버전, 상태 코드(리퀘스트 성공여부를 나타내는 숫자코드), 그 상태 코드를 설명한 프레이즈, 옵션의 리스폰스 헤더 필드와 바디로 구성된다. 



## 스테이트리스(stateless) 프로토콜

HTTP는 상태를 저장하지 않는 스테이트리스(stateless) 프로토콜이다.

리퀘스트와 리스폰스를 교환하는 동안에 상태(status)를 관리하지 않는다. 그렇기에 HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해서는 전혀 기억하지 않는다.

그러나, 웹이 진화함에 따라 스테이트리스 특성만으로는 처리하기 어려운 일이 증가하게 된다. ex) 쇼핑몰에 로그인했을 때 다른 페이지로 이동하더라도 로그인 상태를 유지해야 함.
따라서 '쿠키(Cookie)' 를 도입하여 상태가 있는 세션을 만들수 있도록 하게 된다. 



## HTTP 메소드

리퀘스트 메소드의 종류   

- GET : 리소스 표시
    - 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 한다.
    - 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다.
    - GET을 사용하는 요청은 오직 데이터를 받기만 한다. 
- HEAD : 메시지 헤더 취득
    - GET과 같은 기능이지만, 메시지 바디는 돌려주지 않음.
    - URI 유효성과 리소스 갱신 기간을 확인하는 목적 등으로 사용.
- POST : 엔티티 전송
    - 특정 리소스에 엔티티를 제출할 때 사용한다. 
    - 요청된 자원을 생성(create) 한다.
- PUT : 파일 전송
    - 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다. 클라이언트 측은 요청된 URI를 그래도 사용하는 것으로 간주한다. 
    - 요청된 자원을 수정(update) 한다.
    - 단, 인증 기능이 없어 보안 문제가 생길 수 있기 때문에 일반적인 웹사이트에서는 사용하지 않는다.   
    ※ 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있다.
- DELETE : 파일 삭제
    - PUT 메소드와는 반대로 동작한다. 리퀘스트 URI로 지정된 리소스의 삭제를 요구.
    - 단, PUT과 마찬가지로 보안상의 문제가 있기 때문에 일반적인 웹사이트에서는 사용하지 않음.
- TRACE : 경로 조사
    - Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백을 발생시킨다.
    - 클라이언트는 TRACE 메소드를 이용하여 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.
    - 단, XST와 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않음.
- CONNECT : 프록시에 터널링 요구
    - 프록시에 터널 접속 기능을 요청한다. TCP 통신을 터널링 시키기 위해 사용된다.
    - 주로 SSL과 TLS 등의 포로토콜로 암호화된 것을 터널링 하기 위해 사용됨.
- OPTIONS : 웹서버에서 지원되는 메소드의 종류를 확인
    - 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용.

메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재한다.   


※ 메소드는 대소문자를 구분하기 때문에 대문자로 써줘야 한다.



## 지속 연결로 접속량을 절약

초기에는 HTTP 통신을 한 번 할때마다 TCP에 의해 연결을 종료해야 했다. 그러나, 다량의 이미지를 포함한 문서 등이 늘어나게 되며 여러 번 리퀘스트를 보낼 때마다 TCP 연결과 종료를 하게 되면 무의미한 통신량이 늘어나는 문제가 발생했다.

이를 해결하기 위해, 지속 연결(Presistent Connections)라는 방법을 고안하여 어느 한쪽이 연결을 종료하지 않는 이상 TCP 연결을 계속 유지할 수 있게 되었다.   

지속 연결의 장점   
- 서버에 대한 부하가 줄어듦
- 리퀘스트와 리스폰스가 빠르게 완료되어 웹페이지를 빨리 표시할 수 있음
- 파이프라이닝을 가능하게 하여 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있게 됨.



## 쿠키(Cookie)를 사용한 상태(status) 관리

HTTP는 스테이트리스(stateless) 프로토콜이다. 그래서 상태를 유지한 채 현재의 리퀘스트를 처리하기 위해서 스테이트리스 프로토콜은 그대로 둔 채 쿠키(Cookie)라는 시스템을 도입하였다.

- 쿠키 : 리퀘스트와 리스폰스에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템.

서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 쿠키를 서버가 아닌 클라이언트에 보존하게 됨. 

다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신한다.

서버는 클라이언트가 보내온 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 알 수 있다.


