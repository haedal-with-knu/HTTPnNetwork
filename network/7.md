# 7. HTTPS의 안정성

# HTTP의 약점

이렇게 많이 사용되는 HTTP에는 약점 또한 존재한다.

- 평문(암호화 하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능
- 특정 웹 서버나 웹 클라이언트의 구현상의 약점(취약성 or 시큐리티 홀)
- Java나 PHP 등으로 구축한 웹 애플리케이션 취약성



## 도청 가능성

HTTP 자신을 암호화하지 못하기 때문에 통신 전체가 암호화되지는 않는다.



**TCP/IP: 도청 가능한 네트워크**

어느 서버와 클라이언트가 통신을 할 때 통신 경로에 있는 모든 네트워크 기기나 케이블, 컴퓨터가 자신의 소유일 수는 없다. 그렇기에 악의를 가진 누군가가 엿볼 수 있다.

암호화 되지 않은 통신, 암호화된 통신 모두 통신 내용을 엿볼 수 있는데, 암호화된 통신은 메시지 속의 의미까지는 알아낼 수 없을 수 있지만 암호화된 메시지 자체는 엿볼 수 있다.

같은 세그먼트의 통신을 도청할 때는 네트워크 상에 흐르고 있는 패킷을 수집하는 것만으로 충분하다. 패킷을 수집할 때는 패킷 캡쳐(ex.Wireshark)나 스니퍼라는 툴을 사용한다.



### 도청 피하기 by 암호화

암호화에는 몇 가지 대상이 있다.



**통신 암호화**

HTTP에는 암호화 구조가 없지만, SSL이나 TLS라는 다른 프로토콜을 조합하면 HTTP의 통신 내용을 암호화할 수 있다.

SSL을 이용해 안전한 통신로를 확보한 후에 그 통신로를 이용해 HTTP 통신을 한다. SSL을 조합한 HTTP를 HTTPS(HTTP over SSL)라고 한다.



**콘텐츠 암호화**

통신하고 있는 콘텐츠의 내용 자체를 암호화하는 방법이 있다. HTTP 자체에는 암호화 기능이 없기 때문에 HTTP 메시지에 포함되는 콘텐츠만 암호화하는 것이다.

이런 경우, 클라이언트에서 HTTP 메시지를 암호화해서 출력하는 처리가 필요하다.

그러기 위해서는 먼저 클라이언트와 서버가 콘텐츠의 암호화나 복호화 구조를 가지고 있어야 하므로, 평상시 사용하는 브라우저나 웹 서버에서는 이용하기 어렵다. 주로 웹 서비스 등에서 사용된다.



### 위장 가능성


HTTP를 사용한 리퀘스트나 리스폰스에서는 *통신 상대를 확인하지 않아* 리퀘스트를 보낸 서버가 정말로 URI에서 지정된 호스트인지, 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 여부를 알 수 없다.

위와 같이, HTTP 통신은 누구나 리퀘스트 할 수 있으며, 상대가 누구든지 간에 어떠한 리스폰스를 반환한다.(단, IP 주소나 포트 등에서 그 웹 서버에 액세스 제한이 없는 경우)   


- 리퀘스트를 보낸 웹 서버가 원래 의도한 리스폰스를 보내야 하는 웹 서버인지 확인할 수 없다. 위장한 웹 서버일 가능성 존재.
- 리스폰스를 반환한 곳의 클라이언트가 원래 의도한 리퀘스트를 보낸 클라이언트인지 확인할 수 없다. 위장한 웹 클라이언트일 가능성 존재.
- 통신하고 있는 상대가 액세스가 허가된 상대인지 아닌지를 확인할 수 없다.
- 대량의 리퀘스트에 의한 DoS 공격(서비스 불능 공격)을 방지할 수 없다.


그렇기에 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하는 SSL을 이용해 상대를 확인한다.

제3의 기관에서 발행되는 증명서는 서버나 클라이언트가 실제로 존재하는지 증명한다. 이 증명서를 이용하여 통신 상대는 자신이 통신하고자 하는 서버임을 나타내고, 이용자는 개인정보 유출의 위험성이 줄어든다.



### 변조 가능성

*완전성을 증명할 수 없다면 변조가 가능해진다.* 
완전성이란 정보의 정확성을 가리키는데, 그것을 증명할 수 없다면 정보가 정확한지 아닌지 알 수 없게 된다.

HTTP에서 완전성을 증명할 수 없다는 것은 만약 리퀘스트나 리스폰스가 발신된 후 상대가 수신하기 전 변조되었다고 해도 이 사실을 알 수 없다는 뜻이다. 

이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 것을 중간자 공격(Man in the Middle 공격)이라고 한다.   


**변조를 방지하려면?**

자주 사용되는 방법으로는 MD5나 SHA-1 등의 해시 값을 확인하는 방법, 디지털 서명을 확인하는 방법 등이 있다.

그러나 확실하게 변조를 방지하기 위해서는 HTTPS를 사용해야 한다.



# HTTPS

## HTTPS란?

HTTP에 암호화나 인증 등을 추가하여 보안을 강화한 것을 HTTPS(HTTP Secure)라고 부른다.

HTTPS를 사용한 통신은 URI에 `http://` 가 아닌 `https://` 를 사용한다. 또, 브라우저에서 액세스하면 자물쇠 마크가 표시되는 등 HTTP와는 다르게 표시된다.



## HTTPS=HTTP+SSL

HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아니라, HTTP에서 통신을 담당하는 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체한 것이다.

일반적으로 HTTP는 직접 TCP와 통신하지만 SSL을 사용하게 되면 HTTP가 SSL과 통신하고, SSL이 TCP와 통신한다. 

HTTPS를 사용함으로써 암호화, 증명서, 완전성 보호를 이용할 수 있게 된다. 현재 SSL은 전세계에서 널리 사용하고 있는 네트워크 보안 기술이다.



### 공개키 암호화 방식

SSL에서는 공개키 암호화 방식을 사용한다.

암호의 알고리즘이 공개되어 있고, 키를 비밀로 함으로써 안전성을 유지한다. 암호화와 복호화에 이 키를 사용하는데, 키가 없으면 암호를 풀 수 없는 방식이다.

그렇지만, 반대로 키가 있다면 누구나 암호를 풀 수 있기 때문에 공격자가 키를 알게 되면 암호화의 의미가 없어지게 되는 단점이 있다.



**공통키 암호**

암호화와 복호화에 공통적으로 하나의 키를 사용하는 방식을 공통키 암호라고 한다.

공통키 암호화 방식은 상대에게 키를 넘겨주어야 한다. 그러나 네트워크를 통해 키를 넘겨줄 때 통신이 도청되면 공격자에게 공통키를 빼앗기게 된다.



**두 키를 사용하는 공개키 암호**

공개키 암호 방식으로 공통키 암호의 문제를 해결할 수 있다.

공개키 암호에서는 서로 다른 두 개의 키 쌍을 사용하는데, 한쪽은 `비밀키(private key)`, 다른 한쪽은 `공개키(public key)`라고 한다. 비밀키는 누구에게도 알려져서는 안되며 공개키는 말그대로 공개된 키이다.

공개키 암호를 사용한 암호화에서 암호를 보내는 측은 상대의 공개키를 사용해 암호화하고, 상대는 자신의 비밀키를 이용해 복호화를 시도한다. 이 방식은 비밀키를 (공통키 암호 방식처럼)통신으로 보낼 필요가 없기 때문에 도청에 의해 키가 유출될 일이 없다.



**HTTPS = 하이브리드 암호 시스템**

HTTPS는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템이다. 

공개키 암호는 공통키 암호에 비해 처리 속도가 늦기 때문에 하이브리드 암호 시스템에서는 키를 교환하는 곳에서는 공개키 암호를, 그 후의 통신에서 메시지를 교환할 때는 공통키 암호를 사용한다.



## 증명서
: 공개키가 정확한지 아닌지를 증명

그러나 공개키 암호에도 문제점이 있다. 공개키가 진짜인지 아닌지를 증명할 수 없다는 것이다. 이를 해결하기 위해 인증 기관(CA)와 그 기관이 발행하는 공개키 증명서가 이용된다.

먼저 서버의 운영자가 인증 기관에 공개키를 제출하고, 인증 기관은 제출된 공개키에 디지털 서명을 하여 서명된 공개키를 만든다. 그리고 공개키 인증서에 서명이 완료된 공개키를 담게 된다.

서버는 이 공개키가 담긴 인증서(=증명서)를 클라이언트에게 보내 공개키 암호로 통신을 한다. 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해 서버의 공개키를 인증하게 된다.

여기서, 증명서는 반드시 안전하게 클라이언트에게 전달되어야 한다. 그래서 많은 브라우저가 주요 인증 기관의 공개키를 미리 내장한 상태로 제품을 내놓는다.




### 클라이언트 증명서

클라이언트 증명서를 이용하면 서버 증명서처럼 서버가 통신하고 있는 상대가 의도한 클라이언트라는 것을 증명해 주는 클라이언트 인증을 할 수 있다. 그러나 이 증명서에도 몇가지 문제가 있다.

먼저, 증명서의 입수와 배포 문제가 있다. 유저가 직접 클라이언트 증명서를 인스톨해야 하고 유료로 구입해야 하기 때문이다. 그래서 일반적으로 은행의 인터넷 뱅킹 등 비용을 들일 필요가 있는 곳에서만 사용된다.

또 다른 문제점으로는 이 인증서는 어디까지나 클라이언트가 존재하는지만 증명할 뿐, 사용자의 존재 유무를 증명하는 것은 아니라는 것이다. 즉, 클라이언트 증명서가 들어간 컴퓨터를 사용한다면 누구나 클라이언트 증명서를 쓸 수 있는 단점이 있다.



## HTTPS의 구조(여기는 나중에 다시 수정하기!!)

HTTPS를 통해 우리는 안전한 통신이 가능하다. 

1. 클라이언트가 Client Hello 메시지를 송신하며 SSL 통신을 시작한다. 메시지 내용에는 클라이언트가 제공하는 SSL 버전을 지정하는 정보와, 암호 스위드(Cipher Suite)로 불리는 리스트(사용하는 암호화의 알고리즘/키 사이즈 등) 등이 있다.
2. 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답한다. 클라이언트와 마찬가지로 SSL버전과 암호 스위트를 포함한다. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트의 내용에서 선택된 것이다.
3.  서버가 Certificate 메시지를 송신한다. 메시지에는 공개키 증명서가 포함되어 있다.
4. 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션이 끝났음을 통지한다.
5. SSL의 최초 네고시에이션이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답한다. 메시지에는 Pre-Master secret이 포함되어 있는데, 이는 통신을 암호화하는 데 사용된다. 이 메시지는 3의 공개키 증명서에서 꺼낸 공개키로 암호화 되어있다.
6. 클라이언트는 Change Cipher Spec 메시지를 송신한다. 이 메시지 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타낸다.
7. 클라이언트가 Finished 메시지를 송신한다. 이 메시지는 접속 전체의 체크 값을 포함하고 있다. 네고시에이션의 성공 여부는 서버가 이 메시지를 올바르게 복호화할 수 있는지로 판단된다.
8. 서버에서도 Change Cipher Spec 메시지를 송신한다.
9. 서버에서도 Finished 메시지를 송신한다.
10. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속이 확립된다. SSL로 보호가 되고 있는 상황에서 이제부터는 애플리케이션 계층의 프로토콜에 의해 통신한다.(HTTP 리퀘스트를 송신한다)
11. 애플리케이션 계층의 프로토콜에 의한 통신이다. HTTP 리스폰스를 송신한다.
12. 클라이언트가 접속을 종료한다. 접속을 끊을 때는 close_notify 메시지를 송신한다. 그 후, TCP FIN 메시지를 보내 TCP 통신을 종료한다.



### HTTPS의 사용

HTTPS는 HTTP에 비해 상당히 발전된 안전성을 갖췄지만, 실제로 널리 이용된 지는 얼마 되지 않았다. 그 이유는 다음과 같다.

- HTTPS에서 SSL을 사용하게 되면 처리가 늦어짐
- 통신 속도가 느려짐
- CPU나 메모리 등의 리소스를 다량으로 소비해 처리가 느려지기도 함

이를 해결하기 위해 SSL 엑셀러레이터라는 하드웨어(appliance 서버)를 사용하여 SSL의 처리만 SSL 엑셀러레이터에 맡겨 부하를 분산하도록 하기도 한다.