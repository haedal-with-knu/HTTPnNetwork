# 8. 액세스 주체를 확인하는 인증

# 인증이란?

서버에 액세스하고 있는 사람이 누구인지 알기 위해서는 상대 클라이언트에게 이름을 알려달라고 해야 한다. 다만, 액세스 하고 있는 사람이 '○○○'라고 이름을 밝혀도 우리는 그 이름이 진짜인지 아닌지 알 수 없다. 시스템에 액세스하는 권한을 가진 '○○○' 본인인지를 확인하려면 `[등록된 본인만이 알고 있는 정보]`나 `[등록한 본인만이 가지고 있는 정보]` 등으로 확인해야 한다.

- 패스워드 : 본인만이 알고 있는 문자열 정보
- 원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한 번 쓰고 버리는 패스워드 등의 정보
- 전자 증명서 : 본인(단말기) 만이 가지고 있는 정보
- 바이오 매트릭스 : 지문이나 홍채 등 인간의 신체 정보
- IC카드 등 : 본인만이 가지고 있는 정보

단, 상대 클라이언트가 가짜여도 위와 같은 정보들을 알고 있다면 컴퓨터는 본인으로 인식해버린다. 그렇기에 패스워드 같은 본인만이 알고 있는 정보는 결코 타인에게 알려지지 않게 해야 한다.



다음은 HTTP/1.1에서 사용하는 인증 방법들에 대한 것이다.

# BASIC 인증

BASIC 인증은 HTTP/1.0에 구현된 방법으로, 현재도 일부에서는 사용되고 있다. 이는 웹 서버와 대응하고 있는 클라이언트 사이에서 이루어지는 인증 방식이다.



## BASIC 인증 단계

1. BASIC 인증이 필요한 리소스에 리퀘스트가 있는 경우 서버는 상태 코드 401과 함꼐 인증의 방식(BASIC)과 Request-URI의 보호 공간을 식별하기 위한 문자열을 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환한다.
2. 상태 코드 401을 받은 클라이언트는 BASIC 인증을 위해 유저ID와 패스워드를 서버에 송신할 필요가 있다. 송신하는 문자열은 유저ID와 패스워드를 `콜론:` 으로 연결한 문장을 `Base64`라는 형식으로 인코드한 것이다. 이 문자열을 Authorization 헤더 필드에 포함해서 리퀘스트를 송신하게 된다.
3. Authorization 헤더 필드를 포함한 리퀘스트를 수신한 서버는 인증정보가 정확한지를 확인하게 된다. 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환한다.

그러나, Base64는 암호화가 아니기 때문에 도청된 경우에는 유저ID와 패스워드를 뺏길 가능성이 있다. 또, BASIC 인증을 한 번 하고 나면 일반 브라우저에서는 로그아웃할 수 없다는 문제도 있다. 

실제로 그다지 많이 사용되는 방법은 아니다.



# DIGEST 인증

BASIC 인증의 약점을 보완하는 방식이다. DIGEST 인증은 챌린지 리스폰스 방식을 사용하여 BASIC 인증처럼 패스워드를 있는 그대로 직접 보내지 않기 때문에 패스워드 유출 가능성이 줄어든다.

챌린지 리스폰스: 상대방에게 인증 리퀘스트를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한다. 이 값을 상대에게 송신하여 인증을 하는 방식이다.



### DIGEST 인증 단계

1. 인증이 필요한 리소스에 리퀘스트가 있을 경우, 서버는 상태 코드 401 과 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더 필드에 포함하여 리스폰스를 반환한다.    WWW-Authenticate 헤더 필드에 반드시 포함되어야 하는 요소로는 `realm`과 `nonce`가 있는데, 클라이언트와 이 값을 서버에 보내는 것으로 인증한다.
2. 상태 코드 401을 수신한 클라이언트는 DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 포함하여 리스폰스를 반환한다. Authorization 헤더 필드에 반드시 포함되어야 하는 정보는 `'username`, `realm`, `nonce`, `uri`, `response` 이다. 이 중에서 `realm`과 `nonce`는 서버에서 받은 것을 사용한다.
3. 리퀘스트를 받은 서버는 인증 정보가 정확한지 확인하고, 정보가 정확하다면 Request-URI의 리소스를 포함한 리스폰스를 반환한다.

DIGEST 인증은 BASIC 인증에 비해 높은 보안 등급을 지원하지만, HTTPS에 비하면 낮다. DIGEST로는 패스워드의 도청을 방지할 수는 있지만, 이외에 위장을 방지하는 기능은 없다. 따라서, DIGEST도 많이 사용되는 인증방법은 아니다.



# SSL 클라이언트 인증

SSL 클라이언트 인증은 HTTPS의 클라이언트 인증서를 이용한다. 이 방법을 이용하면 제 3자가 사용자의 정보를 '위장'하는 것을 방지할 수 있다.

사전에 등록된 클라이언트에서의 액세스인지 아닌지를 확인할 수 있다.



### SSL 클라이언트 인증 단계

SSL 클라이언트 인증을 할 때는 미리 클라이언트에 클라이언트 증명서를 배포하고 설치해 두어야 한다.

1. 인증이 필요한 리소스의 리퀘스트가 있을 경우에는 서버가 클라이언트에게 클라이언트 증명서를 요구하는 `Certificate Request` 메시지를 송신한다.
2. 유저는 클라이언트 증명서를 선택하고, 클라이언트는 클라이언트 증명서에 `Client Certificate` 메시지를 송신한다.
3. 서버는 클라이언트 증명서를 검증하고 검증 경로가 정확하다면 클라이언트의 공개키를 얻게된다. 그 이후 HTTPS에 의한 암호화를 시작한다.



### 단독이 아닌 SSL 클라이언트 인증

SSL 클라이언트 인증은 대부분 단독이 아니라 폼 베이스 인증과 합쳐 2-factor 인증의 하나로써 이용된다.

2-factor 인증이란 패스워드 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 함께 사용해 인증을 하는 방법이다. 첫 번째 인증 정보로 패스워드를 사용하고 그 다음 유저의 본인 확인 과정을 거친다. 이로 인해 본인이 올바른 컴퓨터에서 접속하고 있음을 확인할 수 있다. 



# 폼 베이스 인증

폼 베이스 인증은 HTTP 프로토콜로 사양이 정의되어 있는 인증 방식은 아니다. 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보(Credential)를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식이다.  

대부분의 경우 미리 등록해 둔 자격 정보인 유저 ID(임의의 문자열, 메일주소 등)와 패스워드를 입력하여 이를 웹 애플리케이션 측에 송신하고 검증 결과를 바탕으로 검증 성공 여부를 결정한다.  



## 폼 베이스 인증의 대중화

HTTP가 표준으로 제공하는 BASIC 인증이나 DIGEST 인증은 사용상의 문제와 보안상의 문제로 거의 사용되지 않는다. 또한, 보안 등급이 높은 SSL 클라이언트 인증도 거의 사용되지 않는다.

폼 베이스 인증은 인증 표준을 따르는 것이 아니라 웹 사이트 별로 다르게 인증을 구현하기 때문에 안전한 방법으로 구현하면 높은 보안 등급을 유지할 수 있다.



## 세션 관리와 쿠키에 의한 구현

폼 베이스 인증은 표준적인 사양이 없지만 일반적으로 쿠키를 사용하여 세션을 관리하는 방법을 많이 사용하고 있다.

인증 과정은 서버 측의 웹 애플리케이션 등에 의해 클라이언트가 송신해온 유저ID와 패스워드가 사전에 등록된 것과 일치하는지를 검증하며 이루어진다. 

그러나 HTTP는 스테이트리스(Stateless) 프로토콜이기 때문에 방금 전에 인증을 성공했던 유저라도 프로토콜 레벨에서는 유지할 수가 없다. 다음에 이 유저가 다시 액세스했다고 하더라도 다른 유저와 구별하지 못하기 때문에 세션 관리와 쿠키를 사용하여 HTTP에 없는 상태 관리 기능을 보충하게 된다. 

1. 클라이언트와 서버에 유저ID나 패스워드 등의 자격 정보를 포함한 리퀘스트를 송신한다. 보통은 POST 메소드가 사용되어 엔티티 바디에 자격 정보를 저장하며, 이 때 HTML 폼 화면 표시와 입력 데이터의 송신에는 HTTPS 통신을 이용한다. 
2. 서버 측은 유저를 식별하기 위해 세션 ID를 발행한다. 클라이언트에서 수신한 자격 정보를 검증하는 것으로 인증을 하고, 그 유저의 인증 상태를 세션ID와 연관지어 서버 측에 기록한다. 클라이언트 측에 송신할 때는 Set-Cookie 헤더 필드에 세션ID를 저장하여 리스폰스를 반환한다.


    ※ 세션 ID가 제 3자에게 유출되면 악용될 수 있기 때문에 세션 ID는 추측하기 어려운 문자열을 사용해야 한다. 그리고 크로스 사이트 스크립팅 등의 취약성이 존재하는 경우에도 보안상의 문제가 있을 수 있으므로 쿠키에는 httponly 속성을 부여해야 한다.


3. 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장해 둔다. 다음에 서버에 리퀘스트를 송신할 때는 브라우저가 자동으로 쿠키를 송출하기 때문에 세션 ID가 서버에 송신된다.

폼 베이스 인증에서는 자격 정보를 교환하는 방법 뿐만 아니라, 패스워드 등의 자격 정보를 서버 측에 어떻게 보존해야 하는지도 표준화되어 있지 않다.