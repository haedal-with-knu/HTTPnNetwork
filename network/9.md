# 9. 프로토콜

# HTTP 기반의 프로토콜

웹의 용도가 굉장히 다양해지면서 사람들은 HTTP라는 프로토콜의 한계를 느끼게 되었다. 그러나 새로운 프로토콜을 만들기에는 이미 웹 브라우저 환경이 널리 퍼져있었기 때문에 HTTP를 기반으로 한 추가적인 형태의 프로토콜들이 몇가지 구현되었다.



# SPDY

SPDY는 Google에서 2010년에 발표한 SPDY는 HTTP/1.1의 성능 제한을 해결하고 웹 페이지의 로딩 시간을 줄이기 위해 개발한 비표준 개방형 네트워크 프로토콜이다.    
HTTP/2.0 프로토콜의 출발점으로 SPDY 사양이 채택되었다. Google은 HTTP/2.0이 SPDY를 대체할 것이라고 말하며 크롬에서 SPDY 지원 기능을 제거하였다. 



## HTTP의 병목현상

SNS에 많은 사람들이 정보를 실시간으로 올리면 웹 사이트에 그 정보들이 추가되며 단시간에 대량의 정보갱신이 발생한다. 이 정보들을 최대한 빨리 실시간으로 표시하기 위해서는 서버의 정보가 갱신될 때 클라이언트의 화면에 바로 반영해야 한다. 

그러나 HTTP에서는 이 처리를 제대로 할 수 없다. HTTP에서 서버의 정보가 갱신되었는지 알기 위해서는 클라이언트가 항상 서버 측에 확인을 해야 하는데, 만약 정보가 갱신되지 않았다면 불필요한 통신이 발생하게 되며 다음과 같은 HTTP 병목 현상이 일어날 수 있다.

- 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다
- 리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것은 불가능하다.
- 리퀘스트/리스폰스 헤더를 압축하지 않은 채로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.
- 장황한 헤더를 보낸다. 매번 같은 헤더를 보내는 것은 낭비이다.
- 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지 않다.

이를 해결하기 위해서는 몇가지 방법이 있다.



### Ajax

Ajax는 JavaScript나 DOM 조작 등을 활용하여 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법이다. 페이지의 일부만 갱신되기 때문에 리스폰스로 전송되는 데이터 양이 줄어든다는 장점이 있지만, 실시간으로 서버에서 정보를 얻으려고 하면 대량의 리퀘스트가 발생하는 문제가 있다.



### Comet

Comet은 서버 측의 콘텐츠 갱신이 있었을 경우, 클라이언트의 리퀘스트를 기다리지 않고 클라이언트에 리스폰스를 보내기 위한 방법이다. 보통 리퀘스트가 오면 리스폰스를 바로 반환하지만, Comet에서는 리스폰스를 보류상태로 했다가, 서버의 콘텐츠가 갱신되었을 때 리스폰스를 반환함으로써 서버에서 갱신된 콘텐츠가 있을 때 바로 클라이언트에 반영할 수 있다.

그러나, 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해 커넥션을 유지하는 시간이 길어진다는 단점이 있다. 



### SPDY의 설계, 기능

SPDY는 HTTP를 완전히 바꾸는 것이 아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작한다. 그리고 SPDY는 보안을 위해 표준으로 SSL을 사용하도록 되어 있다. 또, SPDY를 사용하면서도 HTTP의 요소들을 그대로 사용할 수 있다.

SPDY를 이용하여 다음 기능들을 HTTP에 추가할 수 있다.

- 다중화 스트림
- 리퀘스트의 우선순위 부여
- HTTP 헤더 압축
- 서버 푸시 기능
- 서버 힌트 기능

SPDY를 이용하면 HTTP의 병목 현상을 해결할 수 있다. 그러나, 대부분의 웹사이트의 문제는 HTTP의 병목 현상만으로 일어나지 않기 때문에 추가적인 작업이 필요할 수 있다.   



# WebSocket

 WebSocket은 Ajax와 Comet으로는 해결할 수 없는 병목현상을 새로운 프로토콜과 API를 이용해 해결할 수 있도록 개발되었다.



## WebSocket 프로토콜

WebSocket은 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식이다. HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변함이 없지만 한번 접속을 확립하면 WebSocket을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 된다.



WebSocket 프로토콜의 주요 특징은 다음과 같다.

### 서버 푸시 기능

서버에서 클라이언트에 데이터를 푸시하는 서버 푸시 기능을 제공한다. 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있게 된다.   


### 통신량의 감소

WebSocket은 접속을 한번 확립하면 접속을 유지하려고 한다. HTTP에 비해 자주 접속을 하는 오버헤드가 적어지고, 또 헤더의 사이즈도 작기 때문에 통신량을 줄일 수 있다. 따라서 핸드쉐이크(handshake)절차를 밟을 필요가 없다.

※ 핸드쉐이크/리퀘스트

WebSocket으로 통신을 하려면 HTTP의 Upgrade 헤더 필드를 사용해서 프로토콜을 변경하는 것으로 핸드쉐이크를 실시한다.

※ 핸드쉐이크/리스폰스

앞선 리퀘스트에 의한 리스폰스는 상태 코드 101로 반환된다.



# HTTP/2

HTTP/1.1에서 HTTP/2 로의 가장 큰 변화는 향상된 성능이다. 

Chrome은 Chrome 6부터 SPDY를 지원하기 시작했지만, 대부분의 장점은 HTTP/2에 포함돼 있기 때문에 SPDY 지원을 중단하기로 결정하였고,  SPDY에 대한 지원은 2016년 초에 종료되었다. 그와 동시에 Chrome에서도 TLS의 NPN 확장에 대한 지원을 종료하고 ALPN 확장으로 대체하기로 하였다. 따라서 서버 개발자는 HTTP/2 및 ALPN으로의 전환할 것이 권장된다.



# WebDAV

WebDAV는 HTTP/1.1에서 확장된 프로토콜로, 웹 서버의 콘텐츠에 대해서 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템이다. 

- 컬렉션(Collection) : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념. 조작을 컬렉션 단위로 할 수 있다.
- 자원(Resource) : 파일이나 컬렉션을 리소스라고 부른다.
- 프로퍼티(Property) : 리소스의 프로퍼티를 정의한 것이다. 정의는 '이름=값'의 형식으로 이루어진다.
- 잠금(Lock) : 파일을 편집할 수 없는 상태로 한다. 여러 사람이 동시에 편집하는 경우 작성되는 것을 예방한다.

이 외에 여러 메소드들과 상태 코드가 추가되었다.