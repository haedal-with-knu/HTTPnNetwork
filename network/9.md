# 9. 프로토콜

# HTTP를 기본으로 하는 프로토콜

웹의 용도가 굉장히 다양해지면서 사람들은 HTTP라는 프로토콜의 한계를 느끼게 되었다. 그러나 새로운 프로토콜을 만들기는 이미 웹 브라우저라는 환경이 널리 퍼져있기 때문에 HTTP를 기반으로 한 추가적인 형태의 프로토콜들이 몇가지 구현되었다.



# SPDY

Google에서 2010년에 발표한 SPDY는 HTTP/1.1의 성능 제한을 해결하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발되었다. 그리고 HTTP/2.0 프로토콜의 출발점으로 SPDY 사양이 채택되었다. 



## HTTP의 병목현상

SNS에 많은 사람들이 정보를 실시간으로 올리면 웹 사이트에 그 정보들이 추가되며 단시간에 대량의 정보갱신이 발생하게 된다. 이 정보들을 최대한 빨리 실시간으로 표시하기 위해선느 서버의 정보가 갱신될 때 클라이언트의 화면에 반영해야 한다. 

그러나 HTTP에서는 이 처리를 제대로 할 수 없다. HTTP에서 서버의 정보가 갱신되었는지 알기 위해서는 클라이언트가 항상 서버 측에 확인을 해야 하는데, 만약 정보가 갱신되지 않았다면 불필요한 통신이 발생하게 되며 다음과 같은 HTTP 병목 현상이 일어날 수 있다.

- 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다
- 리퀘스트는 클라이언트에서만 시작할 수있다. 리스폰스만 받는 것은 불가능하다.
- 리퀘스트/리스폰스 헤더를 압축하지 않은 채로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.
- 장황한 헤더를 보낸다. 매번 같은 헤더를 보내는 것은 낭비이다.
- 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지 않다.

이를 해결하기 위해서는 몇가지 방법이 있다.



### Ajax

Ajax는 JavaScript나 DOM 조작 등을 활용하여 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법이다. 페이지의 일부만 갱신되기 때문에 리스폰스로 전송되는 데이터 양이 줄어든다는 장점이 있지만, 실시간으로 서버에서 정보를 취득하려고 하면 대량의 리퀘스트가 발생한다는 문제가 있다.



### Comet

Comet은 서버 측의 콘텐츠 갱신이 있었을 경우, 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법이다. 보통 리퀘스트가 오면 리스폰스를 바로 반환하지만, Comet에서는 리스폰스를 보류상태로 하고, 서버의 콘텐츠가 갱신되었을 때 리스폰스를 반환한다. 이로 인해 서버에서 갱신된 콘텐츠가 있으면 바로 클라이언트에 반영할 수 있다.

그러나, 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해 커넥션을 유지하는 시간이 길어진다.



### SPDY의 설계, 기능

SPDY는 HTTP를 완전히 바꿔 놓는 것이 아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작한다. 그리고 SPDY는 보안을 위해 표준으로 SSL을 사용하도록 되어 있다. 

SPDY가 세션 계층으로 들어감으로써 데이터의 흐름을 제어하지만, HTTP의 커넥션은 확립되어 있기 때문에 HTTP의 요소들을 그대로 사용할 수 있다.

SPDY를 이용하여 다음 기능들을 HTTP에 추가할 수 있다.

- 다중화 스트림
- 리퀘스트의 우선순위 부여
- HTTP 헤더 압축
- 서버 푸시 기능
- 서버 힌트 기능

SPDY를 이용하면 HTTP의 병목 현상을 해결할 수 있다. 그러나, 대부분의 웹사이트의 문제는 HTTP의 병목 현상만이 아니기 때문에 부수적으로 할 작업들이 있다.



# WebSocket

HTTP라는 프로토콜을 사용하는 이상, Ajax와 Comet으로는 병목 현상을 해결할 수 없다. WebSocket은 새로운 프로토콜과 API를 이용해 이 문제를 해결할 수 있도록 개발되었다.



## WebSocket 프로토콜

WebSocket은 웹 서버와 클라이언트가 한번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식이다. HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것에는 변함이 없지만 한번 접속을 확립하면  WebSocket을 사용하여 서버와 클라이언트 어느 쪽에서도 송신을 할 수 있게 된다.

WebSocket 프로토콜의 주요 특징은 다음과 같다.



### 서버 푸시 기능

서버에서 클라이언트에 데이터를 푸시하는 서버 푸시 기능을 제공한다. 그 덕에 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있다.



### 통신량의 삭감

WebSocket은 접속을 한번 확립하면 접속을 유지하려고 한다. HTTP에 비해 자주 접속을 하는 오버헤드가 적어지고, 또 헤더의 사이즈도 작기 때문에 통신량을 줄일 수 있다. 따라서 핸드쉐이크(handshake)절차를 밟을 필요가 없다.

※ 핸드쉐이크/리퀘스트

WebSocket으로 통신을 하려면 HTTP의 Upgrade 헤더 필드를 사용해서 프로토콜을 변경하는 것으로 핸드쉐이크를 실시한다.

※ 핸드쉐이크/리스폰스

앞선 리퀘스트에 의한 리스폰스는 상태 코드 101로 반환된다.



# HTTP/2.0 (?)

HTTP/1.1에서 HTTP/2로의 가장 큰 변화의 초점은 향상된 성능이다. 다중화, 헤더 압축, 우선순위화, 프로토콜 협상과 같은 주요 기능은 개방 프로토콜인 SPDY에서 진화했으나 이는 비표준 프로토콜이었다. 

Chrome은 Chrome 6부터 SPDY를 지원하기 시작했지만, 대부분의 장점은 HTTP/2에 포함돼 있기 때문에 SPDY 지원을 중단하기로 결정하였고,  SPDY에 대한 지원은 2016년 초에 종료되었다. 그와 동시에 Chrome에서도 TLS의 NPN 확장에 대한 지원을 종료하고 ALPN 확장으로 대체하기로 하였다. 따라서 서버 개발자는 HTTP/2 및 ALPN으로의 전환할 것이 권장된다.



# WebDAV

WebDAV는 HTTP/1.1에서 확장된 프로토콜로, 웹 서버의 콘텐츠에 대해서 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템이다. 

- 컬렉션(Collection) : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념. 조작을 컬렉션 단위로 할 수 있다.
- 자원(Resource) : 파일이나 컬렉션을 리소스라고 부른다.
- 프로퍼티(Property) : 리소스의 프로퍼티를 정의한 것이다. 정의는 '이름=값'의 형식으로 이루어진다.
- 잠금(Lock) : 파일을 편집할 수 없는 상태로 한다. 여러 사람이 동시에 편집하는 경우 작성되는 것을 예방한다.

이 외에 여러 메소드들과 상태 코드가 추가되었다.